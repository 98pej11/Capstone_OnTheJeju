# 디자인 패턴 적용

## 객체지항의 오해와 사실, 디자인 패턴 적용

- “객체 지향의 사실과 오해” 책을 통해 객체 지향의 의미를 좀 더 이해할 수 있는 계기 되었습니다. 그래서 "객체 지향 언어인 자바"를 책에서 말한 역할, 책임, 협력의 관점으로 바라보며 설계할 수 있다는 것을
  알게 되었습니다. 이후 "객체 지향의 역할, 책임, 협력"을 23가지 패턴으로 만든 “GOF의 23가지 디자인 패턴”도 학습하여 본 프로젝트에 적용하여 좀더 객체 지향적인 코드로 바꾸었습니다

([디자인 패턴 학습 내용 링크](https://github.com/suheonjoo/Study-Document/tree/master/%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4))

### (1) "관광지 위치" 전략 패턴 적용 -> 더 효과적인 enum 활용을 알게 되어 업데이트

- 전략 패턴: “상황내용을 포함하는(가지고 있는) 역할”과 “상황에 따른 다양한 전략을 포함하는 역할”을 나누어 전략들을 분리하는 패턴을 만들었습니다 저는 동서남북의 클래스를 따로 분리하여 "위치 정보를 가지고
  있는 역할"을 만들고, 이러한 "위치 정보를 관리하는 역할" LocationStrategy 인터페이스를 만들어 객체들간의 협력 관계를 만들었습니다

<img  alt="stragetyPatternPackage" src="./img/stragetyPatternPackage.png?raw=true" width = "30%" height = "30%"  >
<img  alt="stragetyPatternExample" src="./img/stragetyPatternExample.png?raw=true" width = "30%" height = "30%"  >

- 전략 패턴을 사용한 이유: 현재 동서남북으로 위치정보를 분리하 것은 설문조사와 각 읍별 관광지의 개수를 고려하여 저희 임의의 적절한 지억을 나누었습니다. 이는 관광지가 새로 생길수 있어 지역별 관광지 개수 변경이
  되는 우려가 있었습니다 그래새 유지보수를 더 편리하게 하기 위해서 전략 패턴을 적용하였습니다.

[커밋 경로](https://github.com/suheonjoo/Capstone-JejuTourRecommend/commit/d4cb7eb58c30391103cde2f2489c7b8f27440cda)

<details>

  <summary> 전략 패턴 코드 (👈 Click)</summary>

```java
public class DefaultLocation implements LocationStrategy{
    @Override
    public List<Location> getLocation() {

        List<Location> DefaultList = Arrays.asList(Location.Jeju_si, Location.Aewol_eup, Location.Hallim_eup,
                Location.Hangyeong_myeon, Location.Jocheon_eup, Location.Gujwa_eup,
                Location.Daejeong_eup, Location.Andeok_myeon, Location.Seogwipo_si,
                Location.Namwon_eup, Location.Pyoseon_myeon, Location.Seongsan_eup, Location.Udo_myeon
        );

        return DefaultList;
    }
}
```

```java

public class EastLocation implements LocationStrategy{
    @Override
    public List<Location> getLocation() {

        List<Location> eastList = Arrays.asList(Location.Namwon_eup, Location.Pyoseon_myeon, Location.Seongsan_eup);
        return eastList;
    }
}
```

```java

public interface LocationStrategy {

    List<Location> getLocation();

}

```

```java

public class NorthLocation implements LocationStrategy {
    @Override
    public List<Location> getLocation() {

        List<Location> northList = Arrays.asList(Location.Aewol_eup, Location.Jeju_si, Location.Jocheon_eup,
                Location.Gujwa_eup, Location.Udo_myeon);
        return northList;
    }
}

```

```java
public class SouthLocation implements LocationStrategy{
    @Override
    public List<Location> getLocation() {

        List<Location> southList = Arrays.asList(Location.Seogwipo_si);
        return southList;
    }
}

public class WestLocation implements LocationStrategy{
    @Override
    public List<Location> getLocation() {
        List<Location> southList = Arrays.asList(Location.Seogwipo_si);
        return southList;
    }
}
```

</details>

<details>

  <summary> enum 타입의 재발견! 본문 확인 (👈 Click)</summary>

#### enum 타입의 재발견

[본문 링크](https://github.com/suheonjoo/Study-Document/blob/master/%EC%A0%9C%EC%A3%BC%20%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%20%EA%B4%80%EB%A0%A8%20doc/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%20doc/docs/%EC%9C%84%EC%B9%98%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20enum%20%ED%85%8C%EC%9D%B4%EB%B8%94%EB%A1%9C%20%EA%B0%9C%EC%84%A0.md)


</details>

### (2) "메타 데이터" 빌더 패턴 적용

- 빌더패턴: “많은 인스턴스를 관리하는 역할”과 “해당 인스턴스를 생성하는 역할”을 만들어 기존 구조를 세부적(구체적)으로 분리시키는 패턴
- 메타 데이터 인스턴스를 관리하는 역햘은 MetaDataBuilder 인터페이스에게 역할 주었고 상황별 메타데이터를 생성하는 역할은 MetaDataDirector 클래스에게 역할을 부여하여 적용하였습니다

<img  alt="builderPatternExample" src="./img/builderPatternExample.png?raw=true" width = "60%" height = "60%">
<img  alt="metaDataPackage" src="./img/metaDataPackage.png?raw=true" width = "30%" height = "30%">

- 빌더 패턴을 사용한 이유: 새로운 메타 데이터가 생길때마다 list와 map을 사용하여 일일히 정보블 반환하는 것에 번거로움이 있었습니다 또한 메타데이터의 정보를 수정되는 경우도 다수 발생하는 것에 대비하여 위와
  같이 빌더 패턴을 적용하였습니다

<details>

  <summary> 빌더 패턴 코드 (👈 Click)</summary>

```java
public interface MetaDataBuilder {  
  
   MetaDataBuilder addMetaData(int id, String name);  
  
   MetaData getMetaDataDummy();  
}
```

```java
public class DefaultMetaDataBuilder implements MetaDataBuilder {  
  
   private List<MetaDataDetail> metaDataDetailList;  
  
   @Override  
   public MetaDataBuilder addMetaData(int id, String name) {  
      if (this.metaDataDetailList == null) {  
         this.metaDataDetailList = new ArrayList<>();  
      }  
      MetaDataDetail metaDataDetail = new MetaDataDetail(id, name);  
      this.metaDataDetailList.add(metaDataDetail);  
      return this;  
   }  
  
   @Override  
   public MetaData getMetaDataDummy() {  
      return new MetaData(metaDataDetailList);  
   }  
  
}
```


```java
@Data  
public class MetaData {  
  
   private List<MetaDataDetail> metaDataList;  
  
   public MetaData(List<MetaDataDetail> metaDataList) {  
      this.metaDataList = metaDataList;  
   }  
}
```

```java
@Data  
public class MetaDataDetail {  
  
   private int id;  
   private String name;  
  
   public MetaDataDetail(int id, String name) {  
      this.id = id;  
      this.name = name;  
   }  
}
```

```java
public class MetaDataDirector {  
  
   int id = 1;  
   private MetaDataBuilder metaDataBuilder;  
  
   public MetaDataDirector(MetaDataBuilder metaDataBuilder) {  
      this.metaDataBuilder = metaDataBuilder;  
   }  
  
   public MetaData categoryMetaData() {  
      return metaDataBuilder  
         .addMetaData(id++, "전체")  
         .addMetaData(id++, "뷰")  
         .addMetaData(id++, "가격")  
         .addMetaData(id++, "편의시설")  
         .addMetaData(id++, "서비스")  
         .getMetaDataDummy();  
   }  
  
   public MetaData locationMetaData() {  
      return metaDataBuilder  
         .addMetaData(id++, "전체")  
         .addMetaData(id++, "북부")  
         .addMetaData(id++, "남부")  
         .addMetaData(id++, "서부")  
         .addMetaData(id++, "동부")  
         .getMetaDataDummy();  
   }  
  
}
```


</details>



### (3) "Service" Facade 패턴 적용

- Facade 패턴: "어떤 역할들의 집합"을 만들어 클라이언트 요청을 따로 “한번에” 관리하는 패턴입니다
- 본 프로젝트에서 Service 역할을 @Transaction 에 readOnly 옵션이 들어가는 곳과 들어가기 Service의 역할을 분리하였습니다. 그래서 @Transaction 에 readOnly 옵션 유뮤에
  따라 클래스를 분리하였으며, 해당 클래스들을 Facade 패턴을 사용하여 객체 관리하도록 하였습니다.

<img  alt="FavoriteServiceFacade" src="./img/FavoriteServiceFacade.png?raw=true" width = "30%" height = "30%">

<img  alt="FavoriteServiceSeperate" src="./img/FavoriteServiceSeperate.png?raw=true" width = "30%" height = "30%">

(성능 최적화 내용은 "프로젝트 종료 이후 혼자서 진행한 리팩토링"의 6. @Transaction 최적화에 있습니다)

- Facade 패턴을 사용한 이유: repository 특성(readonly 유무)별로 service를 분리하였지만, controller 에서 service 종류에 따라 호출하게 되면 변경사항이 있을시 수정할
  부분이 다수라 변경이 번거로웠습니다. 또한 persentation 영역과 application 영역을 분리하기 위해 적용하였습니다. 이로써, service 호출하는 곳을 한 곳에 관리하여 controller가 "한 개의 service"에서 호출할 수 있도록 하여 유지보수를 편리하게 하였습니다.


<details>

  <summary> Facade 패턴 코드 (👈 Click)</summary>

```java
@Service  
@RequiredArgsConstructor  
public class FavoriteFacade {  
  
   private final FavoriteCommandUseCase favoriteCommandUseCase;  
  
   private final FavoriteQueryUseCase favoriteQueryUseCase;  
  
   public void postFavoriteForm(FavoriteSpotSaveDto favoriteSpotSaveDto) {  
      favoriteCommandUseCase.postFavoriteForm(favoriteSpotSaveDto);  
   }  
  
   public FavoriteDto newFavoriteList(WishListSaveDto wishListSaveDto) {  
      return favoriteCommandUseCase.newFavoriteList(wishListSaveDto);  
   }  
  
   public void deleteSpotInFavoriteList(Long favoriteId, Long spotId) {  
      favoriteCommandUseCase.deleteSpotInFavoriteList(favoriteId, spotId);  
   }  
  
   public WishListDto getFavoriteList(Long memberId, Pageable pageable) {  
      return favoriteQueryUseCase.getFavoriteList(memberId, pageable);  
   }  
  
   public void deleteFavoriteList(Long favoriteId) {  
  
      favoriteQueryUseCase.deleteFavoriteList(favoriteId);  
   }  
  
   public TopTenRecommendedSpotsDto recommendSpotList(Long favoriteId, List<Long> spotIdList) {  
  
      return favoriteQueryUseCase.recommendSpotList(favoriteId, spotIdList);  
  
   }  
  
   public FavoriteSpotsDto favoriteSpotList(Long favoriteId) {  
      return favoriteQueryUseCase.favoriteSpotList(favoriteId);  
  
   }  
  
}
```


</details>