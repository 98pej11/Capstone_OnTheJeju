## JPA n+1

1. 패치조인을 사용함, where in절 쿼리 내용이 적은 경우라. 한번에 가져와서 어플리케이션에서 filter하는게 맞다고 판단함
    - -> 한번에 다 조회해서 dto에 각각 담음
        - 2-1번하고 차이점은 이 service에 반환하는 api가 페이징dto가 아니여서 페치조인함, 페이징 컬렉션 페이징은 못하니깐

2. n+1 발생되는 테이블에서 조회를 하고 dto에 붙이는 형식으로 함 이때 여기서
    1. where 의 in절 조건 리스트가 많지 않는 경우: 그냥 디비에서 꺼내서 어플리케이션 영역에서 collection 자료구조의 groupby, limit를 사용해서 붙이는 형식으로 했음,한번에 많은 양을
       디비에서 가져오는것은 리소스 과부하라고 생각
        - -> 어플리케이션에서 groupby, limit
    2. in절 조건에 리스트사이즈가 큰 경우:  디비에서 groupby, limit 로 처리함 -> db에서 groupby , limit c -> 
	- groupby 는 whishlist 에서 각 패키지마다 관광지별로 3개의 사진을 보여주는데 
		- 각 패키지안에 관광지id 기준으로 groupby하고 limit 3을 걸어주어 처리하였다 
        - 이후 real mysql 실행계획을 어떻게 보고 인덱싱 처리 유무를 어떻게 판단하는지 볼려고 구글링 엄청함 보니깐 intellij에 유용한 기능 엄청 많음.
            - 이걸로 실행계획 보고 드디어 real mysql 이 이해가기 시작했음 -> 진짜 백과 사전같이 볼수 있었음
                - ~~(물론 처음볼때 이해가 안갔는데 어떻게든 정리하면서 한번 정독한게 도움 되었기에 가능한거 )~~
