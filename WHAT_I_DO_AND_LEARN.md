
# 알게된 사실들


- OSIV = false 로 설정으로 인한 버그 
-> 대부분의 reference 에서는 비지니스 계층에서의 트랜잿션 그림 그려져 있었으나, view 에서 가져온 영속성 컨텍스트 또한 조회만 가능하여 수정 작업을 하려면 다시 리포지토리에서 해당 엔티티를 가져와야한다 
  - 결론 비지니스 영역에서의 영속성 컨텍스트 내용은 뷰에서 수정 작업을 하면 안됬을 뿐만 아니라, 뷰 영역에서의 영속성 컨텍스트내용도 비지니스 영역에서 수정작업을 하면 안된다
-  jpa n+1 처리 어떻게 했나 다시 쿼리 문을 봄

# 내가 처리한 것

## JPA n+1 어떻게 처리했나?

1. 패치조인을 사용함, where in절 쿼리 내용이 적은 경우라. 한번에 가져와서 어플리케이션에서 filter하는게 맞다고 판단함
   - -> 한번에 다 조회해서 dto에 각각 담음
     - 2-1번하고 차이점은 이 service에 반환하는 api가 페이징dto가 아니여서 페치조인함, 페이징 컬렉션 페이징은 못하니깐

2. n+1 발생되는 테이블에서 조회를 하고 dto에 붙이는 형식으로 함 이때 여기서
  1. where 의 in절 조건 리스트가 많지 않는 경우: 그냥 디비에서 꺼내서 어플리케이션 영역에서 collection 자료구조의 groupby, limit를 사용해서  붙이는 형식으로 했음,한번에 많은 양을 디비에서 가져오는것은 리소스과부하라고 생각
      - -> 어플리케이션에서 groupby, limit
   2. in절 조건에 리스트사이즈가 큰 경우:  디비에서 groupby, limit 로 처리함 -> db에서 groupby , limit c
      - 이후 real mysql 실행계획을 어떻게 보고 인덱싱 처리 유무를 어떻게 판단하는지 볼려고 구글링 엄청함 보니깐 intellij에 유용한 기능 엄청 많음.
        - 이걸로 실행계획 보고 드디어 real mysql 이 이해가기 시작했음 -> 진짜 백과 사전같이 볼수 있었음 
          - ~~(물론 처음볼때 이해가 안갔는데 어떻게든 정리하면서 한번 정독한게 도움 되었기에 가능한거 )~~























